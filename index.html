<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> Espen Braastad &middot; Espen Braastad </title>

  
  <link rel="stylesheet" href="http://espebra.github.io/website/css/poole.css">
  <link rel="stylesheet" href="http://espebra.github.io/website/css/syntax.css">
  <link rel="stylesheet" href="http://espebra.github.io/website/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="stylesheet" href="http://espebra.github.io/website/highlightjs/default.min.css">
  <script src="http://espebra.github.io/website/highlightjs/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://espebra.github.io/website/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="http://espebra.github.io/website/favicon.ico">

  
  <link href="http://espebra.github.io/website/index.xml" rel="alternate" type="application/rss+xml" title="Espen Braastad" />

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-59220530-1', 'auto');
    ga('send', 'pageview');
  
  </script>
</head>

  <body>
    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>Espen Braastad</h1>
    </div>

    <ul class="sidebar-nav">
      <li><a href="http://espebra.github.io/website/">Home</a> </li>
      
        <li><a href="http://espebra.github.io/website/post">Posts</a></li>
    </ul>
  </div>
</div>

    <div class="content container">
      <div class="posts">
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/remote-console-on-hp-proliant-microserver-g7-n54l/">
              Remote console on HP ProLiant MicroServer G7 N54L
            </a>
          </h1>
          <span class="post-date">Sat, Aug 30, 2014</span>
          <p>I bought the <a href="http://www8.hp.com/us/en/products/proliant-servers/product-detail.html?oid=6280786">HP ProLiant MicroServer G7 N54L</a> a while ago. I threw in a <a href="http://www8.hp.com/us/en/products/oas/product-detail.html?oid=4275612">HP MicroServer Remote Access Card Kit</a> to get remote console and power management. While the power management, web UI and CLI (over ssh) works fine out of the box, the remote console (KVM) does not. What happens is that the KVM client shows the following <code>Out of range</code> message:</p>

<p><img src="http://espebra.github.io/website/img/outofrange.png" alt="Out of range" />
</p>

<p>To fix this, go into the BIOS. Navigate to Advanced, PCI Express Configuration and Embedded VGA Control like this:</p>

<p><img src="http://espebra.github.io/website/img/bios1.png" alt="BIOS 1" />

<img src="http://espebra.github.io/website/img/bios2.png" alt="BIOS 2" />
</p>

<p>Flip from &ldquo;Always enabled&rdquo; (default) to &ldquo;Auto Detect&rdquo;. Save and quit. Then, make sure that your monitor is connected to the VGA port on the RAC instead of the embedded VGA port.</p>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/altibox-tv-and-data-over-the-same-ethernet-cable/">
              Altibox, TV- og datatrafikk over samme nettverkskabel
            </a>
          </h1>
          <span class="post-date">Thu, May 22, 2014</span>
          <p>Altibox leverer en hjemmesentral hvor man henter ut TV-signal og internettilgang fra to (eller flere) forskjellige RJ45-porter. Som trådløs router har hjemmesentralen kun et minimum av funksjonalitet, og man skal ikke være en veldig avansert bruker før man vil rekonfigurere hjemmesentralen som en bridge og heller ha en egen trådløs router på baksiden. Dette gir også mening dersom boligen har flere etasjer, og hjemmesentralen ikke er kraftig nok til å levere god nok trådløs dekning.</p>

<p>Denne posten viser hvordan TV og datatrafikk kan sendes via èn nettverkskabel til et annet sted i boligen ved hjelp av to stk Mikrotik 951G-2HnD. RB951G-2HnD er en fleksibel trådløs router (2,4 GHz) med 5 stk 1 Gbps-porter beregnet på hjemmebruk. Utstyret kobles som skjemaet under viser.</p>

<p><img src="http://espebra.github.io/website/img/mikrotik-altibox.png" alt="Diagram" />
</p>

<p>Mikrotik A, konfigurasjon:</p>

<pre><code>/interface vlan add name=vlan-10 vlan-id=10 interface=ether2 disabled=no
/interface bridge add name=br-vlan10 disabled=no
/interface bridge port add interface=&quot;vlan-10&quot; bridge=&quot;br-vlan10&quot; disabled=no
/interface ethernet set numbers=ether5-slave-local master-port=none
/interface bridge port add interface=&quot;ether5-slave-local&quot; bridge=&quot;br-vlan10&quot; disabled=no
</code></pre>

<p>Mikrotik A, portoversikt:</p>

<pre><code>Port 1: Internett inn (datakabel fra Altibox hjemmesentral)
Port 2: Trunk til Mikrotik B
Port 3: Data
Port 4: Data
Port 5: TV inn (TV-kabel fra Altibox hjemmesentral)
</code></pre>

<p>Mikrotik B, konfigurasjon:</p>

<pre><code>/interface vlan add name=vlan-10 vlan-id=10 interface=ether2 disabled=no
/interface bridge add name=br-vlan10 disabled=no
/interface bridge port add interface=&quot;vlan-10&quot; bridge=&quot;br-vlan10&quot; disabled=no
/interface ethernet set numbers=ether4-slave-local master-port=none
/interface ethernet set numbers=ether5-slave-local master-port=none
/interface bridge port add interface=&quot;ether4-slave-local&quot; bridge=&quot;br-vlan10&quot; disabled=no
/interface bridge port add interface=&quot;ether5-slave-local&quot; bridge=&quot;br-vlan10&quot; disabled=no
</code></pre>

<p>I tillegg må Mikrotik B settes opp som en bridge.</p>

<p>Mikrotik B, portoversikt:</p>

<pre><code>Port 1: Data
Port 2: Trunk til Mikrotik A
Port 3: Data
Port 4: TV ut
Port 5: TV ut
</code></pre>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/temperature-trend-monitoring-at-home/">
              Temperature trend monitoring at home
            </a>
          </h1>
          <span class="post-date">Wed, Feb 19, 2014</span>
          

<h2 id="background:88f8b93192da3e559035b25b4d4944bf">Background</h2>

<p>I’ve got balanced ventilation in my apartment. It works OK, but I don’t fully understand how it behaves if knobs are pushed and pots are turned, and I’m definitely not sure if its performance is as good as I should expect.</p>

<p>I’m going to do some measurements to see how the system reacts to changes in the outside temperature and tuning of the various settings. The first parameter to measure is the temperature in the air intake, exhaust air and some of the ventilation valves in the different rooms in the apartment.</p>

<h2 id="hardware:88f8b93192da3e559035b25b4d4944bf">Hardware</h2>

<p>Some temperature sensors are required. Price is an important factor, but so is accuracy. I settled with some sensors from the <a href="http://www.raphnet.net/electronique/usbtenki/index_en.php">USBTenki</a> project. Schematics and software are open source, so you can assemble the sensors yourself if you want to. I didn’t want to, so I bought them ready to run from <a href="http://www.dracal.com/store/products/usbtenki/index.php">Dracal</a>.</p>

<p><img src="http://espebra.github.io/website/img/usbtenki_sensor_on_table.png" alt="Sensor" />
</p>

<ul>
<li>±0.5°C typical accuracy at 25°C</li>
<li>±1°C (max.) accuracy from -10°C to +85°C</li>
<li>±2°C (max.) accuracy from -10°C to +125°C</li>
<li>±3°C (max.) accuracy from -55°C to +125°C</li>
</ul>

<p>The price is 29.99$ CAD per sensor and they ship internationally. I bought five sensors. In addition, I bought some USB extension cords and a cheap bus powered USB hub from <a href="http://www.dx.com/">Deal Extreme</a> to allow all sensors to be connected simultaneously.</p>

<h2 id="software:88f8b93192da3e559035b25b4d4944bf">Software</h2>

<p><a href="http://munin-monitoring.org/">Munin</a> will be used to create graphs to show the temperature over time:</p>

<p>Munin is a networked resource monitoring tool that can help analyze resource trends and “what just happened to kill our performance?” problems. It is designed to be very plug and play. A default installation provides a lot of graphs with almost no work.</p>

<p>Munin is written in Perl and is available in the repositories of most Linux distributions. Installation is easy:</p>

<pre><code># Fedora / Redhat / CentOS
sudo yum install munin munin-node

# Debian / Ubuntu
sudo apt-get install munin munin-node
</code></pre>

<p>USBTenki host software is used to communicate with the sensors from Linux.</p>

<h2 id="setup:88f8b93192da3e559035b25b4d4944bf">Setup</h2>

<p>A couple of the sensors are mounted in the ventilation tubes for permanent monitoring, and the other ones are used for temporary monitoring at various locations.</p>

<p><img src="http://espebra.github.io/website/img/usbtenki_sensor_mounted.png" alt="Sensor" />
</p>

<p>Since the number of sensors and the locations will vary, I need a munin plugin that is flexible. I wrote a simple multigraph plugin that will detect new sensors and create a new graph per sensor that is added. These graphs are completely standardised and (frankly) pretty boring:</p>

<p><img src="http://espebra.github.io/website/img/sensor_905270-week.png" alt="Sensor" />

<img src="http://espebra.github.io/website/img/sensor_E10084-week.png" alt="Sensor" />

<img src="http://espebra.github.io/website/img/sensor_E10087-week.png" alt="Sensor" />
</p>

<p>Data loaning is used to aggregate the different sensor data and to modify their presentation (type, colour, label, etc) as I see fit, without having to modify the plugin itself. This will ensure that old sensor data is kept whenever modifications are made, and the data from each sensor can be used in multiple aggregated graphs if needed.</p>

<p>Data loaning configuration example and result:</p>

<pre><code>[sensor;ventilation]
    address 127.0.0.1
    use_node_name no
    temp.update no
    temp.graph_title Temperature
    temp.graph_args --base 1000
    temp.graph_vlabel Celcius
    temp.graph_scale no
    temp.graph_category temperature
    temp.graph_order \
        E10084=oslo;caesar:sensor_E10084.output \
        E10090=oslo;caesar:sensor_E10090.output \
        E10087=oslo;caesar:sensor_E10087.output 
    temp.E10084.draw LINE1
    temp.E10084.colour FF00FF
    temp.E10084.label Air exhaust (inside)
    temp.E10087.draw LINE1
    temp.E10087.colour FF0000
    temp.E10087.label Air intake (outside)
    temp.E10090.draw LINE1
    temp.E10090.colour 00FF00
    temp.E10090.label Air intake (inside)
</code></pre>

<p><img src="http://espebra.github.io/website/img/temp-week.png" alt="Aggregated, by week" />
</p>

<p><img src="http://espebra.github.io/website/img/temp-day.png" alt="Aggregated, by day" />
</p>

<p>Air flow, carbon dioxide, humidity and power consumption are other aspects that are interesting to monitor as well, but those will have to wait until I find reasonably priced sensors with satisfying accuracy and quality.</p>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/el6-rootfs-on-tmpfs-update2/">
              CentOS/RHEL/SL 6: root filesystem on tmpfs, UPDATE #2
            </a>
          </h1>
          <span class="post-date">Sun, Jun 23, 2013</span>
          

<p>In a <a href="http://espebra.github.io/website/post/el6-rootfs-on-tmpfs">previous post</a>, I’ve explained how to boot EL6 from memory without having / needing a physical disk.</p>

<p>A bright reader, Jeff, came up with an alternative method. This alternative method does not involve dd’ing the image into a loop device, but instead copying the contents of the disk image directly into tmpfs. The result is higher write/read performance and generally lower memory requirements. The latter because unused disk space does not consume memory, which is important to consider when choosing the method to use in production systems.</p>

<h2 id="example:8b7afac85e4821a1da5a25923e910783">Example</h2>

<p>I got a lot of questions by e-mail on the previous posts regarding the subject and how to actually getting it to work, so this time I’ve created a complete set of files to get you going with Jeff’s method:</p>

<ul>
<li>The original <code>dmsquash-live-root</code>. You won’t need this, but I added it as a reference.</li>
<li>The updated <code>dmsquash-live-root</code>. You might need to look at this to understand what is going on.</li>
<li>The patch which is the diff of the two previous files. This one is used in the kickstart file below as a base64 encoded string.</li>
<li>The complete example kickstart file. This is a rather default CentOS 6.4 x86_64. The root password is being set to ‘foobar’.</li>
</ul>

<h2 id="build-the-disk-image:8b7afac85e4821a1da5a25923e910783">Build the disk image</h2>

<pre><code>$ sudo yum install livecd-tools
$ sudo livecd-creator --config=centos64-pxe.ks --fslabel=centos64-pxe
$ sudo livecd-iso-to-pxeboot centos64-pxe.iso
</code></pre>

<p>The last command will output <code>vmlinuz0</code> and <code>initrd0.img</code>. Put these on your webserver, <a href="http://example.com/">http://example.com/</a>.</p>

<h2 id="boot-a-host-on-the-disk-image:8b7afac85e4821a1da5a25923e910783">Boot a host on the disk image</h2>

<p>Boot it using DHCP, iPXE and the following iPXE script:</p>

<pre><code>#!ipxe 
initrd http://example.com/initrd0.img
kernel http://example.com/vmlinuz0 initrd=/initrd0.img root=/centos64-pxe.iso rootfstype=auto rw liveimg toram size=4096
boot
</code></pre>

<p>Note the size boot parameter. The patch will set the tmpfs size (in MB) according to this parameter. If the parameter is not set, 2048 is used as a default. The size can be changed runtime using mount, for example:</p>

<pre><code>$ sudo mount -o remount,size=10G,rw /dev/root
</code></pre>

<h2 id="difference-in-memory-usage:8b7afac85e4821a1da5a25923e910783">Difference in memory usage</h2>

<p>The files in the file system in our example will consume around 1 GB of disk space. When booting with a file system (tmpfs) size of 4 GB, the memory usage is quite different between the previous and this (Jeff’s) method:</p>

<h3 id="previous-method:8b7afac85e4821a1da5a25923e910783">Previous method</h3>

<p>The important thing to notice here is that the file system already have allocated 4 GB of memory. This is because the file system already is consuming the amount of memory equivalent to the given size of the file system, independently on the actual disk space being consumed by the files currently in the file system.</p>

<pre><code>[root@lab-e ~]# free -m
             total       used       free     shared    buffers     cached
Mem:          7956       4272       3683          0          6       4135
</code></pre>

<p>One can argue that this is a waste of memory. On the other (conservative) side, one can argue that it is safest to pre-allocate the memory to reserve / ensure enough available memory to the file system should the system need it later. It depend on the use case, I guess.</p>

<h3 id="this-method:8b7afac85e4821a1da5a25923e910783">This method</h3>

<p>The memory footprint of the file system is equivalent of the size of the current files in the file system, which means that free disk space does not consume memory. In some scenarios, this may be a far better approach in terms of resource cost. You may however very well overbook too much, so be careful to leave sufficient memory available for new files to be added. If the file system tries to use more memory than what’s currently available, your system will crash.</p>

<pre><code>             total       used       free     shared    buffers     cached
Mem:          7956       1179       6777          0          0       1001
</code></pre>

<h2 id="difference-in-performance:8b7afac85e4821a1da5a25923e910783">Difference in performance</h2>

<p>The following measurements are far from being scientifically valid.</p>

<h3 id="previous-method-1:8b7afac85e4821a1da5a25923e910783">Previous method</h3>

<pre><code>[root@lab-a ~]# time dd if=/dev/zero of=/foobar bs=1M count=2000 ; time sync
2000+0 records in
2000+0 records out
2097152000 bytes (2.1 GB) copied, 2.45832 s, 853 MB/s

real    0m2.480s
user    0m0.003s
sys 0m2.002s

real    0m0.245s
user    0m0.000s
sys 0m0.037s
</code></pre>

<h3 id="this-method-1:8b7afac85e4821a1da5a25923e910783">This method</h3>

<pre><code>[root@lab-e ~]# time dd if=/dev/zero of=/foobar bs=1M count=2000 ; time sync
2000+0 records in
2000+0 records out
2097152000 bytes (2.1 GB) copied, 0.823305 s, 2.5 GB/s

real    0m0.825s
user    0m0.002s
sys 0m0.821s

real    0m0.001s
user    0m0.000s
sys 0m0.002s
</code></pre>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/el6-rootfs-on-tmpfs-update/">
              CentOS/RHEL/SL 6: root filesystem on tmpfs, UPDATE
            </a>
          </h1>
          <span class="post-date">Thu, Mar 21, 2013</span>
          <p>In EL6.4, the file <code>/usr/share/dracut/modules.d/90dmsquash-live/dmsquash-live-root</code> was updated so that the <a href="http://espebra.github.io/website/post/el6-rootfs-on-tmpfs">previous patch</a> no longer works as it should. I’ve updated the patch, and here it is:</p>

<pre><code>--- original    2013-03-20 16:25:23.698846581 +0100
+++ new 2013-03-21 08:58:11.175339694 +0100
@@ -24,6 +24,8 @@
 getarg readonly_overlay &amp;&amp; readonly_overlay=&quot;--readonly&quot; || readonly_overlay=&quot;&quot;
 overlay=$(getarg overlay)

+getarg toram &amp;&amp; toram=&quot;yes&quot;
+
 # FIXME: we need to be able to hide the plymouth splash for the check really
 [ -e $livedev ] &amp; fs=$(blkid -s TYPE -o value $livedev)
 if [ &quot;$fs&quot; = &quot;iso9660&quot; -o &quot;$fs&quot; = &quot;udf&quot; ]; then
@@ -132,7 +134,10 @@
     BASE_LOOPDEV=$( losetup -f )
     losetup -r $BASE_LOOPDEV $EXT3FS

-    do_live_from_base_loop
+    # Create overlay only if toram is not set
+    if [ -z &quot;$toram&quot; ] ; then
+        do_live_from_base_loop
+    fi
 fi

 # we might have an embedded ext3 on squashfs to use as rootfs (compressed live)
@@ -163,13 +168,66 @@

     umount -l /squashfs

-    do_live_from_base_loop
+    # Create overlay only if toram is not set
+    if [ -z &quot;$toram&quot; ] ; then
+        do_live_from_base_loop
+    fi
+fi
+
+# If the kernel parameter toram is set, create a tmpfs device and copy the 
+# filesystem to it. Continue the boot process with this tmpfs device as
+# a writable root device.
+if [ -n &quot;$toram&quot; ] ; then
+    blocks=$( blockdev --getsz $BASE_LOOPDEV )
+
+    echo &quot;Create tmpfs ($blocks blocks) for the root filesystem...&quot;
+    mkdir -p /image
+    mount -n -t tmpfs -o nr_blocks=$blocks tmpfs /image
+
+    echo &quot;Copy filesystem image to tmpfs... (this may take a few minutes)&quot;
+    dd if=$BASE_LOOPDEV of=/image/rootfs.img
+
+    ROOTFS_LOOPDEV=$( losetup -f )
+    echo &quot;Create loop device for the root filesystem: $ROOTFS_LOOPDEV&quot;
+    losetup $ROOTFS_LOOPDEV /image/rootfs.img
+
+    echo &quot;It's time to clean up.. &quot;
+
+    echo &quot; &gt; Umounting images&quot;
+    umount -l /image
+    umount -l /dev/.initramfs/live
+
+    echo &quot; &gt; Detach $OSMIN_LOOPDEV&quot;
+    losetup -d $OSMIN_LOOPDEV
+
+    echo &quot; &gt; Detach $OSMIN_SQUASHED_LOOPDEV&quot;
+    losetup -d $OSMIN_SQUASHED_LOOPDEV
+    
+    echo &quot; &gt; Detach $BASE_LOOPDEV&quot;
+    losetup -d $BASE_LOOPDEV
+    
+    echo &quot; &gt; Detach $SQUASHED_LOOPDEV&quot;
+    losetup -d $SQUASHED_LOOPDEV
+    
+    echo &quot; &gt; Detach /dev/loop0&quot;
+    losetup -d /dev/loop0
+
+    losetup -a
+
+    echo &quot;Root filesystem is now on $ROOTFS_LOOPDEV.&quot;
+    echo
+
+    ln -s $ROOTFS_LOOPDEV /dev/root
+    printf '/bin/mount -o rw %s %s\n' &quot;$ROOTFS_LOOPDEV&quot; &quot;$NEWROOT&quot; &gt; /mount/01-$$-live.sh
+    exit 0
 fi

 if [ -b &quot;$OSMIN_LOOPDEV&quot; ]; then
     # set up the devicemapper snapshot device, which will merge
     # the normal live fs image, and the delta, into a minimzied fs image
-    echo &quot;0 $( blockdev --getsz $BASE_LOOPDEV ) snapshot $BASE_LOOPDEV $OSMIN_LOOPDEV p 8&quot; | dmsetup create --readonly live-osimg-min
+    if [ -z &quot;$toram&quot; ] ; then
+        echo &quot;0 $( blockdev --getsz $BASE_LOOPDEV ) snapshot $BASE_LOOPDEV $OSMIN_LOOPDEV p 8&quot; | dmsetup create --readonly live-osimg-min
+    fi
 fi

 ROOTFLAGS=&quot;$(getarg rootflags)&quot;
</code></pre>

<p>It may be easier to download it from <a href="http://espebra.github.io/website/resources/patch.sl64.txt">here</a>.</p>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/memory-ballooning/">
              KVM/Xen and libvirt: currentMemory, memory and ballooning. Where did my memory go?
            </a>
          </h1>
          <span class="post-date">Mon, Sep 24, 2012</span>
          <p>KVM and Xen provide a method to change the amount of memory in use by guests at runtime. The method is called memory ballooning [<a href="http://www.linux-kvm.org/page/FAQ#Is_dynamic_memory_management_for_guests_supported.3F">1</a>, <a href="http://rwmj.wordpress.com/2010/07/17/virtio-balloon">2</a>], and it must be supported by the guest operating system to work.</p>

<p>In libvirt, memory allocation (and hence the ballooning capability) for a guest can be configured using the <code>memory</code>, <code>currentMemory</code> and <code>memballoon</code> tags:</p>

<pre><code>&lt;domain type='kvm'&gt;
  [...]
  &lt;memory unit='KiB'&gt;16777216&lt;/memory&gt;
  &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
  [...]
  &lt;devices&gt;
    &lt;memballoon model='virtio'/&gt;
  &lt;/devices&gt;
&lt;/domain&gt;
</code></pre>

<p>The guest can never use more memory than specified in the <code>memory</code> tag and it is the amount of memory the guest will use at boot time. The <code>currentMemory</code> tag, if set, should be less than or equal (default) to <code>memory</code>. The guest will, when the balloon driver is loaded some time during the boot process, adjust itself to use the amount of memory specified by <code>currentMemory</code>. The <code>memballoon</code> tag is being added automatically, so there is really no need to specify it.</p>

<p>The command line tool <code>virsh</code> can later be used on the host to see the current memory configuration for each guest:</p>

<pre><code>[root@host ~]# virsh dominfo guest
Id:             -
Name:           guest
UUID:           4f610a1f-7539-47cf-8299-9534500b340d
OS Type:        hvm
State:          shut off
CPU(s):         1
Max memory:     16777216 kB
Used memory:    1048576 kB
Persistent:     yes
Autostart:      disable
Managed save:   no
</code></pre>

<p>So far, so good. At this point it makes sense to set <code>memory</code> really high on all guests to ensure that we are able to reallocate memory on the fly for all our Linux guests. Doing this might not be a good idea.</p>

<p>Linux as a guest, even though it has a balloon driver, does not seem to behave like one would expect. When <code>memory</code> is set higher than <code>currentMemory</code>, the guest operating system does not see (or use) the amount of memory that it should. Ideally, the value that libvirt reports as Used memory at the host should be visible inside the guest also.</p>

<p>The graphs below show different guests (RHEL6, SL6 and Ubuntu Precise) on KVM (SL6) and Xen (RHEL5). The Y-axis show the amount of memory visible inside the guest (as reported by <code>free -m</code>), while the X-axis show the value of memory. The value of currentMemory is 1024M in all plots – which means that the guests should use 1024M of memory and that the graphs should stay flat out at 1024M, given zero overhead. The graphs show that this is not the reality.</p>

<p><img src="http://espebra.github.io/website/img/kvm-precise-1024.png" alt="KVM, Ubuntu Precise, 1024 MB ram" />
</p>

<p><img src="http://espebra.github.io/website/img/kvm-rhel6-1024.png" alt="KVM, RHEL6, 1024 MB ram" />
</p>

<p><img src="http://espebra.github.io/website/img/xen-sl6-1024.png" alt="Xen, SL6, 1024 MB ram" />
</p>

<p><img src="http://espebra.github.io/website/img/xen-precise-1024.png" alt="Xen, Ubuntu Precise, 1024 MB ram" />
</p>

<p>The graphs with KVM do not have values for 32G memory because the guests went ballistic and OOM-ed.</p>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/filebin-available/">
              Filebin available on http://filebin.net
            </a>
          </h1>
          <span class="post-date">Fri, Jul 27, 2012</span>
          <p><a href="http://filebin.net">Filebin.net</a> was created to try out the new <a href="http://www.w3.org/TR/FileAPI/">File API</a> features in HTML5.</p>

<p>Filebin is a web application that is somewhat similar to a pastebin, except that it&rsquo;s for files. It is written in Python, and the code is available on <a href="http://github.com/espebra/filebin">Github</a>.</p>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/el6-rootfs-on-tmpfs/">
              CentOS/RHEL/SL 6: root filesystem on tmpfs
            </a>
          </h1>
          <span class="post-date">Tue, May 1, 2012</span>
          <p>UPDATE: The patch below has been updated <a href="http://espebra.github.io/website/post/el6-rootfs-on-tmpfs-update">here</a>.</p>

<p>There are several scenarios where conventional hard drives are not really needed. Examples are HPC cluster nodes, virtualization nodes, home theater streaming PCs, silent desktops, internet cafés and embedded systems. Hard drives tend to fail, they are slow, they consume power, they generate heat and noise, and they are quite expensive if you need/want something faster and more reliable than SATA.</p>

<p>This post will show how to run CentOS 6 directly from tmpfs backed by memory, without using the (standard) 512 MB writable overlay. The procedure should be similar for RHEL and Scientific Linux 6.</p>

<p>The resulting boot process will be:</p>

<ul>
<li>Boot a node off a PXE enabled DHCP server.</li>
<li>Chainload into <a href="http://blog.braastad.org/?p=128">iPXE</a>.</li>
<li>Download vmlinuz and a rather large initrd containing the entire filesystem over ftp/http(s). Try to avoid <a href="http://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol">TFTP</a> when downloading the initrd because of its file size limitation and slow transfer speeds.</li>
<li>Once downloaded, the kernel will start and the initrd will be mounted.</li>
<li>The modified dracut scripts in the initrd will create a tmpfs partition in memory with the same size as your filesystem image included in the initrd.</li>
<li>Your entire filesystem image will be copied to the tmpfs partition and attached to a loop device.</li>
<li>This loop device will be used as the new root device, and the boot process continues as usual.</li>
</ul>

<p>This is a screenshot from an ongoing boot process:
<img src="http://espebra.github.io/website/img/centos6-from-tmpfs1.png" alt="Boot process" />
</p>

<p>Now to the procedure:</p>

<p>First, create a custom kickstart file. I&rsquo;ve included the specialties below:</p>

<pre><code>bootloader --location=mbr --append=&quot;toram&quot;
clearpart --all
firstboot --disabled
install
lang en_US.UTF-8
network --bootproto dhcp --device eth0 --onboot yes
part / --fstype=ext4 --size=2048
reboot
zerombr

%packages
patch

%post
cat &gt; /etc/fstab &lt;&lt; END 
tmpfs      /         tmpfs   defaults         0 0
devpts     /dev/pts  devpts  gid=5,mode=620   0 0
tmpfs      /dev/shm  tmpfs   defaults         0 0
proc       /proc     proc    defaults         0 0
sysfs      /sys      sysfs   defaults         0 0
END

# The patch is base64 encoded to avoid having to escape it manually.
cat &gt; /root/dmsquash-live-root.base64 &lt;&lt; EOF_patch
MjFhMjIKPiBnZXRhcmcgdG9yYW0gJiYgdG9yYW09InllcyIKMTM0YzEzNSwxMzgKPCAgICAgZG9f
bGl2ZV9mcm9tX2Jhc2VfbG9vcAotLS0KPiAgICAgIyBDcmVhdGUgb3ZlcmxheSBvbmx5IGlmIHRv
cmFtIGlzIG5vdCBzZXQKPiAgICAgaWYgWyAteiAiJHRvcmFtIiBdIDsgdGhlbgo+ICAgICAgICAg
ZG9fbGl2ZV9mcm9tX2Jhc2VfbG9vcAo+ICAgICBmaQoxNjNjMTY3LDIxMwo8ICAgICBkb19saXZl
X2Zyb21fYmFzZV9sb29wCi0tLQo+ICAgICAjIENyZWF0ZSBvdmVybGF5IG9ubHkgaWYgdG9yYW0g
aXMgbm90IHNldAo+ICAgICBpZiBbIC16ICIkdG9yYW0iIF0gOyB0aGVuCj4gICAgICAgICBkb19s
aXZlX2Zyb21fYmFzZV9sb29wCj4gICAgIGZpCj4gZmkKPiAKPiAjIEkgdGhlIGtlcm5lbCBwYXJh
bWV0ZXIgdG9yYW0gaXMgc2V0LCBjcmVhdGUgYSB0bXBmcyBkZXZpY2UgYW5kIGNvcHkgdGhlIAo+
ICMgZmlsZXN5c3RlbSB0byBpdC4gQ29udGludWUgdGhlIGJvb3QgcHJvY2VzcyB3aXRoIHRoaXMg
dG1wZnMgZGV2aWNlIGFzCj4gIyBhIHdyaXRhYmxlIHJvb3QgZGV2aWNlLgo+IGlmIFsgLW4gIiR0
b3JhbSIgXSA7IHRoZW4KPiAgICAgYmxvY2tzPSQoIGJsb2NrZGV2IC0tZ2V0c3ogJEJBU0VfTE9P
UERFViApCj4gCj4gICAgIGVjaG8gIkNyZWF0ZSB0bXBmcyAoJGJsb2NrcyBibG9ja3MpIGZvciB0
aGUgcm9vdCBmaWxlc3lzdGVtLi4uIgo+ICAgICBta2RpciAtcCAvaW1hZ2UKPiAgICAgbW91bnQg
LW4gLXQgdG1wZnMgLW8gbnJfYmxvY2tzPSRibG9ja3MgdG1wZnMgL2ltYWdlCj4gCj4gICAgIGVj
aG8gIkNvcHkgZmlsZXN5c3RlbSBpbWFnZSB0byB0bXBmcy4uLiAodGhpcyBtYXkgdGFrZSBhIGZl
dyBtaW51dGVzKSIKPiAgICAgZGQgaWY9JEJBU0VfTE9PUERFViBvZj0vaW1hZ2Uvcm9vdGZzLmlt
Zwo+IAo+ICAgICBST09URlNfTE9PUERFVj0kKCBsb3NldHVwIC1mICkKPiAgICAgZWNobyAiQ3Jl
YXRlIGxvb3AgZGV2aWNlIGZvciB0aGUgcm9vdCBmaWxlc3lzdGVtOiAkUk9PVEZTX0xPT1BERVYi
Cj4gICAgIGxvc2V0dXAgJFJPT1RGU19MT09QREVWIC9pbWFnZS9yb290ZnMuaW1nCj4gCj4gICAg
IGVjaG8gIkl0J3MgdGltZSB0byBjbGVhbiB1cC4uICIKPiAKPiAgICAgZWNobyAiID4gVW1vdW50
aW5nIGltYWdlcyIKPiAgICAgdW1vdW50IC1sIC9pbWFnZQo+ICAgICB1bW91bnQgLWwgL2Rldi8u
aW5pdHJhbWZzL2xpdmUKPiAKPiAgICAgZWNobyAiID4gRGV0YWNoICRPU01JTl9MT09QREVWIgo+
ICAgICBsb3NldHVwIC1kICRPU01JTl9MT09QREVWCj4gCj4gICAgIGVjaG8gIiA+IERldGFjaCAk
T1NNSU5fU1FVQVNIRURfTE9PUERFViIKPiAgICAgbG9zZXR1cCAtZCAkT1NNSU5fU1FVQVNIRURf
TE9PUERFVgo+ICAgICAKPiAgICAgZWNobyAiID4gRGV0YWNoICRCQVNFX0xPT1BERVYiCj4gICAg
IGxvc2V0dXAgLWQgJEJBU0VfTE9PUERFVgo+ICAgICAKPiAgICAgZWNobyAiID4gRGV0YWNoICRT
UVVBU0hFRF9MT09QREVWIgo+ICAgICBsb3NldHVwIC1kICRTUVVBU0hFRF9MT09QREVWCj4gCj4g
ICAgIGVjaG8gIlJvb3QgZmlsZXN5c3RlbSBpcyBub3cgb24gJFJPT1RGU19MT09QREVWLiIKPiAg
ICAgZWNobwo+IAo+ICAgICBsbiAtcyAkUk9PVEZTX0xPT1BERVYgL2Rldi9yb290Cj4gICAgIHBy
aW50ZiAnL2Jpbi9tb3VudCAtbyBydyAlcyAlc1xuJyAiJFJPT1RGU19MT09QREVWIiAiJE5FV1JP
T1QiID4gL21vdW50LzAxLSQkLWxpdmUuc2gKPiAgICAgZXhpdCAwCjE2OWMyMTksMjIxCjwgICAg
IGVjaG8gIjAgJCggYmxvY2tkZXYgLS1nZXRzeiAkQkFTRV9MT09QREVWICkgc25hcHNob3QgJEJB
U0VfTE9PUERFViAkT1NNSU5fTE9PUERFViBwIDgiIHwgZG1zZXR1cCBjcmVhdGUgLS1yZWFkb25s
eSBsaXZlLW9zaW1nLW1pbgotLS0KPiAgICAgaWYgWyAteiAiJHRvcmFtIiBdIDsgdGhlbgo+ICAg
ICAgICAgZWNobyAiMCAkKCBibG9ja2RldiAtLWdldHN6ICRCQVNFX0xPT1BERVYgKSBzbmFwc2hv
dCAkQkFTRV9MT09QREVWICRPU01JTl9MT09QREVWIHAgOCIgfCBkbXNldHVwIGNyZWF0ZSAtLXJl
YWRvbmx5IGxpdmUtb3NpbWctbWluCj4gICAgIGZpCg==
EOF_patch

cat /root/dmsquash-live-root.base64 | base64 -d &gt; /root/dmsquash-live-root.patch

patch /usr/share/dracut/modules.d/90dmsquash-live/dmsquash-live-root /root/dmsquash-live-root.patch

ls /lib/modules | while read kernel; do
  echo &quot; &gt; Update initramfs for kernel ${kernel}&quot;
  initrdfile=&quot;/boot/initramfs-${kernel}.img&quot;

  /sbin/dracut -f $initrdfile $kernel
done
%end

%post --nochroot

echo &quot;Copy initramfs outside the chroot:&quot;
ls $INSTALL_ROOT/lib/modules | while read kernel; do
  src=&quot;$INSTALL_ROOT/boot/initramfs-${kernel}.img&quot;
  dst=&quot;$LIVE_ROOT/isolinux/initrd0.img&quot;
  echo &quot; &gt; $src -&gt; $dst&quot;
  cp -f $src $dst
done
%end
</code></pre>

<p><b>Explaination:</b> The post script will apply a patch to <i>/usr/share/dracut/modules.d/90dmsquash-live/dmsquash-live-root</i> before regenerating the initramfs. This patch will add support for the &lsquo;toram&rsquo; boot parameter. Then, the initramfs is being copied to the isolinux directory outside the filesystem image.</p>

<p>Second, use <i>livecd-creator</i> and <i>livecd-iso-to-pxeboot</i> from the <i>livecd-tools</i> package to convert the kickstart file into a bootable vmlinuz and initrd:</p>

<pre><code>$ sudo livecd-creator --config=centos6.ks fslabel=centos6
$ sudo livecd-iso-to-pxeboot centos6.iso
</code></pre>

<p>The commands above will create <i>tftpboot/vmlinuz0</i> and <i>tftpboot/initrd0.img</i>. Put these files on your boot server and create a suitable PXE configuration. <i>livecd-iso-to-pxeboot</i> will create <i>tftpboot/pxelinux.cfg/default</i> which can be used as a template.</p>

<p>Now you are ready to boot one or multiple CentOS 6 in-memory instances over the network!</p>

<p>Another screenshot:
<img src="http://espebra.github.io/website/img/centos6-from-tmpfs-details.png" alt="losetup" />
</p>

<p>Feature request <a href="http://article.gmane.org/gmane.linux.kernel.initramfs/2588">upstream</a>.</p>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/kvm-with-ipxe-in-rhel6/">
              KVM with iPXE in RHEL6
            </a>
          </h1>
          <span class="post-date">Wed, Nov 2, 2011</span>
          <p>A while ago I discovered the amazing <a href="http://ipxe.org">iPXE</a> project. It is a complete PXE implementation with lots of nifty features, based on the <a href="http://etherboot.org/">gPXE</a> project. Redhat ships the gPXE firmware for qemu and KVM, and you might want to use iPXE instead as the iPXE project currently seems to be more active. The major features (copied from <a href="http://ipxe.org">ipxe.org</a>):</p>

<ul>
<li>boot from a web server via HTTP</li>
<li>boot from an iSCSI SAN</li>
<li>boot from a Fibre Channel SAN via FCoE</li>
<li>boot from an AoE SAN</li>
<li>boot from a wireless network</li>
<li>boot from a wide-area network</li>
<li>boot from an Infiniband network</li>
<li>control the boot process with a script</li>
</ul>

<p>First, download the source code:</p>

<pre><code>espen@luft:~$ mkdir ~/git
espen@luft:~$ cd ~/git
espen@luft:~/git$ git clone git://git.ipxe.org/ipxe.git
Cloning into ipxe...
remote: Counting objects: 33376, done.
remote: Compressing objects: 100% (9193/9193), done.
remote: Total 33376 (delta 24642), reused 30782 (delta 22666)
Receiving objects: 100% (33376/33376), 8.02 MiB | 1.94 MiB/s, done.
Resolving deltas: 100% (24642/24642), done.
espen@luft:~/git$ cd ipxe/
espen@luft:~/git/ipxe$
</code></pre>

<p>Then change the general configuration file (<em>src/config/general.h</em>) to suit your needs. Use the <strong>#define</strong> and <strong>#undef</strong> to activate and deactivate various features such as VLAN support, DHCP support, etc. Below is a small part of <a href="https://github.com/ipxe/ipxe/blob/master/src/config/general.h">the header file</a> for you to see.</p>

<pre><code>[...]
#define IWMGMT_CMD   /* Wireless interface management commands */
#define FCMGMT_CMD   /* Fibre Channel management commands */
#define ROUTE_CMD    /* Routing table management commands */
#define IMAGE_CMD    /* Image management commands */
#define DHCP_CMD     /* DHCP management commands */
#define SANBOOT_CMD  /* SAN boot commands */
#define LOGIN_CMD    /* Login command */
#undef  TIME_CMD     /* Time commands */
#undef  DIGEST_CMD   /* Image crypto digest commands */
#undef  LOTEST_CMD   /* Loopback testing commands */
#undef  VLAN_CMD     /* VLAN commands */
#undef  PXE_CMD      /* PXE commands */
#undef  REBOOT_CMD   /* Reboot command */
[...]
</code></pre>

<p>Now it&rsquo;s time compile the firmware.</p>

<pre><code>espen@luft:~/git/ipxe$ cd src/
espen@luft:~/git/ipxe/src$ make bin/virtio-net.rom
  [DEPS] arch/i386/drivers/net/undirom.c
  [DEPS] arch/i386/drivers/net/undipreload.c
  [DEPS] arch/i386/drivers/net/undionly.c
  [DEPS] arch/i386/drivers/net/undinet.c
[...]
  [BIN] bin/virtio-net.rom.bin
  [ZINFO] bin/virtio-net.rom.zinfo
  [ZBIN] bin/virtio-net.rom.zbin
  [FINISH] bin/virtio-net.rom
[...]
espen@luft:~/git/ipxe/src$
</code></pre>

<p>The firmware compiled successfully, and it is ready to use. Log onto the RHEL 6 node, and verify that you have installed the package <strong>gpxe-roms-qemu</strong> (<strong>qemu-kvm</strong> currently depends on <strong>gpxe-roms-qemu</strong>). The directory <em>/usr/share/gpxe/</em> contains the gPXE boot roms from this package.</p>

<p>To use your custom iPXE boot firmware instead, you can build a new rpm package that contains the new rom - or you can simply replace <em>/usr/share/gpxe/virtio-net.rom</em> [gPXE] with your <em>~/git/ipxe/src/bin/virtio-net.rom</em> [iPXE]. As least you will have iPXE boot firmware until the <strong>qemu-roms-qemu</strong> package is updated ;)</p>

<p>Make sure that your virtual machines are using the <strong><a href="http://wiki.libvirt.org/page/Virtio">virtio</a></strong> network device driver, and you are all set:</p>

<pre><code>[...]
&lt;interface type='bridge'&gt;
  [...]
  &lt;model type='virtio'/&gt;
&lt;/interface&gt;
[...]
</code></pre>

<p>Your virtual machines will now be booted using the iPXE boot firmware. Have a look at the <a href="http://ipxe.org/scripting">iPXE scripting documentation</a> for more inspiration!</p>

        </div>
        
        <div class="post">
          <h1 class="post-title">
            <a href="http://espebra.github.io/website/post/munincollector-ng/">
              munincollector-ng
            </a>
          </h1>
          <span class="post-date">Mon, Aug 16, 2010</span>
          <p>Munincollector-ng is a perl script that collects graphs from multiple <a href="http://munin-monitoring.org">munin</a> installations to display them in one page. A scenario where this is helpful is when you have (too) many munin clients on (too) many munin masters, and you want to look through some of the graphs - i.e. the <em>Disk usage in percent</em> (aka <em>df</em>) plugin - without spending/wasting too much time browsing through the less important graphs.</p>

<p>It consists of one perl script and one configuration file. It is being executed regularly by cron. At each run, it iterates through the configuration file; downloads the graphs to a local directory and generates an html file.</p>

<p>Below is some example configuration that will gather the <em>week</em> and <em>month</em> graphs from the <em>df</em> plugin from four separate munin masters (three without authentication and one with authentication). The graphs will be downloaded to <em>/var/www/munincollector-ng/</em>:</p>

<pre><code># General configuration
graph.plugin df
graph.type week month
graph.log /var/log/munincollector-ng.log
graph.dir /var/www/munincollector-ng

# Configuration per munin master you want to collect graphs from.
# The format is: &lt;id&gt;.&lt;option&gt; &lt;value&gt;

# Three munin installations with no authentication
uio.url http://munin.ping.uio.no
foo.url http://foo.com/munin/
bar.url http://bar.com/munin/

# One munin master that requires authentication
baz.url http://baz.com/munin/
baz.realm Munin
baz.username user1
baz.password pass1
baz.netloc baz.com:80
</code></pre>

<p>An example cron job that will execute the script once per day (make sure <em>user</em> have write permissions in <em>/var/www/munincollector-ng/</em>):</p>

<pre><code>8 8 * * * user /usr/local/bin/munincollector-ng -c /etc/munincollector-ng/example.conf
</code></pre>

<p>The script is available from <a href="https://github.com/espebra/munincollector-ng">Github</a>.</p>

<p>PS: Put the <em>logo.png</em> and <em>style.css</em> from your <em>/etc/munin/templates/</em> directory into <em>/var/www/munincollector-ng/</em> to make it look a bit nicer.</p>

        </div>
        
      </div>
    </div>
  </body>
</html>
